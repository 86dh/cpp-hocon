<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cpp-hocon: hocon::config Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cpp-hocon
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehocon.html">hocon</a></li><li class="navelem"><a class="el" href="classhocon_1_1config.html">config</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhocon_1_1config-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hocon::config Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An immutable map from config paths to config values.  
 <a href="classhocon_1_1config.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for hocon::config:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhocon_1_1config.png" usemap="#hocon::config_map" alt=""/>
  <map id="hocon::config_map" name="hocon::config_map">
<area href="classhocon_1_1config__mergeable.html" alt="hocon::config_mergeable" shape="rect" coords="0,0,235,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac23eb9445b4eb9f48fc9bcd96e965b41"><td class="memItemLeft" align="right" valign="top">virtual shared_object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">root</a> () const</td></tr>
<tr class="memdesc:ac23eb9445b4eb9f48fc9bcd96e965b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the.  <a href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">More...</a><br /></td></tr>
<tr class="separator:ac23eb9445b4eb9f48fc9bcd96e965b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827dc49be531922ccb28d9cf8b99f4bf"><td class="memItemLeft" align="right" valign="top">virtual shared_origin&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a827dc49be531922ccb28d9cf8b99f4bf">origin</a> () const</td></tr>
<tr class="memdesc:a827dc49be531922ccb28d9cf8b99f4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the origin of the.  <a href="classhocon_1_1config.html#a827dc49be531922ccb28d9cf8b99f4bf">More...</a><br /></td></tr>
<tr class="separator:a827dc49be531922ccb28d9cf8b99f4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6037de7029e7a99c053257cf405c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__mergeable.html">config_mergeable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a67c6037de7029e7a99c053257cf405c2">with_fallback</a> (std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__mergeable.html">config_mergeable</a> &gt; other) const override</td></tr>
<tr class="memdesc:a67c6037de7029e7a99c053257cf405c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new value computed by merging this value with another, with keys in this value "winning" over the other one.  <a href="classhocon_1_1config.html#a67c6037de7029e7a99c053257cf405c2">More...</a><br /></td></tr>
<tr class="separator:a67c6037de7029e7a99c053257cf405c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b8f810965c489ec3946c632880ac85"><td class="memItemLeft" align="right" valign="top">shared_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a92b8f810965c489ec3946c632880ac85">to_fallback_value</a> () const override</td></tr>
<tr class="memdesc:a92b8f810965c489ec3946c632880ac85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a config to its root object and a <a class="el" href="classhocon_1_1config__value.html" title="An immutable value, following the JSON type schema.">config_value</a> to itself.  <a href="classhocon_1_1config.html#a92b8f810965c489ec3946c632880ac85">More...</a><br /></td></tr>
<tr class="separator:a92b8f810965c489ec3946c632880ac85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03830d94e132e03db0c62a74dc0bfb4"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">resolve</a> () const</td></tr>
<tr class="memdesc:af03830d94e132e03db0c62a74dc0bfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a replacement config with all substitutions (the <code>${foo.bar}</code> syntax, see <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">the spec</a>) resolved.  <a href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">More...</a><br /></td></tr>
<tr class="separator:af03830d94e132e03db0c62a74dc0bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4d59038675d2c7981b70d6d956cc03"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#acb4d59038675d2c7981b70d6d956cc03">resolve</a> (<a class="el" href="classhocon_1_1config__resolve__options.html">config_resolve_options</a> options) const</td></tr>
<tr class="memdesc:acb4d59038675d2c7981b70d6d956cc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> but allows you to specify non-default options.  <a href="classhocon_1_1config.html#acb4d59038675d2c7981b70d6d956cc03">More...</a><br /></td></tr>
<tr class="separator:acb4d59038675d2c7981b70d6d956cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d1e4c68c2094d22f5a3234c48e1ce9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a30d1e4c68c2094d22f5a3234c48e1ce9">is_resolved</a> () const</td></tr>
<tr class="memdesc:a30d1e4c68c2094d22f5a3234c48e1ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the config is completely resolved.  <a href="classhocon_1_1config.html#a30d1e4c68c2094d22f5a3234c48e1ce9">More...</a><br /></td></tr>
<tr class="separator:a30d1e4c68c2094d22f5a3234c48e1ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae857c18ea9ed5d9274092e6fcbf5bfbb"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ae857c18ea9ed5d9274092e6fcbf5bfbb">resolve_with</a> (shared_config source) const</td></tr>
<tr class="memdesc:ae857c18ea9ed5d9274092e6fcbf5bfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> except that substitution values are looked up in the given source, rather than in this instance.  <a href="classhocon_1_1config.html#ae857c18ea9ed5d9274092e6fcbf5bfbb">More...</a><br /></td></tr>
<tr class="separator:ae857c18ea9ed5d9274092e6fcbf5bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938ee4aacd961d7c7f6f2aa04e651c85"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a938ee4aacd961d7c7f6f2aa04e651c85">resolve_with</a> (shared_config source, <a class="el" href="classhocon_1_1config__resolve__options.html">config_resolve_options</a> options) const</td></tr>
<tr class="memdesc:a938ee4aacd961d7c7f6f2aa04e651c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="">config#resolve_with(config)</a> but allows you to specify non-default options.  <a href="classhocon_1_1config.html#a938ee4aacd961d7c7f6f2aa04e651c85">More...</a><br /></td></tr>
<tr class="separator:a938ee4aacd961d7c7f6f2aa04e651c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63746e9542665eea20a51929b7fc150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ae63746e9542665eea20a51929b7fc150">check_valid</a> (shared_config reference, std::vector&lt; std::string &gt; restrict_to_paths) const</td></tr>
<tr class="memdesc:ae63746e9542665eea20a51929b7fc150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates this config against a reference config, throwing an exception if it is invalid.  <a href="classhocon_1_1config.html#ae63746e9542665eea20a51929b7fc150">More...</a><br /></td></tr>
<tr class="separator:ae63746e9542665eea20a51929b7fc150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb726d491df1958769dfb4b53c117c9d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#adb726d491df1958769dfb4b53c117c9d">has_path</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:adb726d491df1958769dfb4b53c117c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is present and non-null at the given path.  <a href="classhocon_1_1config.html#adb726d491df1958769dfb4b53c117c9d">More...</a><br /></td></tr>
<tr class="separator:adb726d491df1958769dfb4b53c117c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf047253216dc24124def4f1a52cf7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#abcf047253216dc24124def4f1a52cf7e">has_path_or_null</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:abcf047253216dc24124def4f1a52cf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is present at the given path, even if the value is null.  <a href="classhocon_1_1config.html#abcf047253216dc24124def4f1a52cf7e">More...</a><br /></td></tr>
<tr class="separator:abcf047253216dc24124def4f1a52cf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dc18b07cc713ca64bbb7884a478566"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a84dc18b07cc713ca64bbb7884a478566">is_empty</a> () const</td></tr>
<tr class="memdesc:a84dc18b07cc713ca64bbb7884a478566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the.  <a href="classhocon_1_1config.html#a84dc18b07cc713ca64bbb7884a478566">More...</a><br /></td></tr>
<tr class="separator:a84dc18b07cc713ca64bbb7884a478566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c5f8dca33d74f9976642f9187f22e3"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; std::string, std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__value.html">config_value</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a83c5f8dca33d74f9976642f9187f22e3">entry_set</a> () const</td></tr>
<tr class="memdesc:a83c5f8dca33d74f9976642f9187f22e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of path-value pairs, excluding any null values, found by recursing <a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">the root object</a>.  <a href="classhocon_1_1config.html#a83c5f8dca33d74f9976642f9187f22e3">More...</a><br /></td></tr>
<tr class="separator:a83c5f8dca33d74f9976642f9187f22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a11684c9de3d5d80548013379f56aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a38a11684c9de3d5d80548013379f56aa">get_is_null</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:a38a11684c9de3d5d80548013379f56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is set to null at the given path, but throws an exception if the value is entirely unset.  <a href="classhocon_1_1config.html#a38a11684c9de3d5d80548013379f56aa">More...</a><br /></td></tr>
<tr class="separator:a38a11684c9de3d5d80548013379f56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c297c07cbff4df9ecc62545e3cb792"><td class="memItemLeft" align="right" valign="top"><a id="ae2c297c07cbff4df9ecc62545e3cb792"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_bool</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:ae2c297c07cbff4df9ecc62545e3cb792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da08a888b47f491da54b099ebfb9284"><td class="memItemLeft" align="right" valign="top"><a id="a9da08a888b47f491da54b099ebfb9284"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>get_int</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a9da08a888b47f491da54b099ebfb9284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b829a9e914d925798371cc2a4cb323"><td class="memItemLeft" align="right" valign="top"><a id="a17b829a9e914d925798371cc2a4cb323"></a>
virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_long</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a17b829a9e914d925798371cc2a4cb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f603aafcfdc2c11b1a53440c683d7"><td class="memItemLeft" align="right" valign="top"><a id="aac0f603aafcfdc2c11b1a53440c683d7"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>get_double</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:aac0f603aafcfdc2c11b1a53440c683d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b874da38a5221f40049aa55e7ad4b85"><td class="memItemLeft" align="right" valign="top"><a id="a7b874da38a5221f40049aa55e7ad4b85"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_string</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a7b874da38a5221f40049aa55e7ad4b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6406591c2e129d35dc709f9c6c69a9"><td class="memItemLeft" align="right" valign="top"><a id="a4e6406591c2e129d35dc709f9c6c69a9"></a>
virtual std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__object.html">config_object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_object</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a4e6406591c2e129d35dc709f9c6c69a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6d0383f761cd66a216a7c94b9c066b"><td class="memItemLeft" align="right" valign="top"><a id="aef6d0383f761cd66a216a7c94b9c066b"></a>
virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><b>get_config</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:aef6d0383f761cd66a216a7c94b9c066b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68344fbd8d2340be8e1bc71b13aa61c3"><td class="memItemLeft" align="right" valign="top"><a id="a68344fbd8d2340be8e1bc71b13aa61c3"></a>
virtual unwrapped_value&#160;</td><td class="memItemRight" valign="bottom"><b>get_any_ref</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a68344fbd8d2340be8e1bc71b13aa61c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea77b2459360ac7e8cb12e90e0a78ca3"><td class="memItemLeft" align="right" valign="top"><a id="aea77b2459360ac7e8cb12e90e0a78ca3"></a>
virtual std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__value.html">config_value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_value</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:aea77b2459360ac7e8cb12e90e0a78ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9e9159e9fb60268db560f04b7e1e26"><td class="memTemplParams" colspan="2"><a id="a1e9e9159e9fb60268db560f04b7e1e26"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e9e9159e9fb60268db560f04b7e1e26"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_homogeneous_unwrapped_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a1e9e9159e9fb60268db560f04b7e1e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8fd7db415f912449bb1dcd15577af1"><td class="memItemLeft" align="right" valign="top"><a id="a8f8fd7db415f912449bb1dcd15577af1"></a>
virtual shared_list&#160;</td><td class="memItemRight" valign="bottom"><b>get_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a8f8fd7db415f912449bb1dcd15577af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb5f22f43419de4959ef910d5aae5ce"><td class="memItemLeft" align="right" valign="top"><a id="adbb5f22f43419de4959ef910d5aae5ce"></a>
virtual std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_bool_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:adbb5f22f43419de4959ef910d5aae5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18535aa5faf6e6f308492371cf63f7c"><td class="memItemLeft" align="right" valign="top"><a id="ae18535aa5faf6e6f308492371cf63f7c"></a>
virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_int_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:ae18535aa5faf6e6f308492371cf63f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70e4364b270efb159db6ac01d9db165"><td class="memItemLeft" align="right" valign="top"><a id="aa70e4364b270efb159db6ac01d9db165"></a>
virtual std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_long_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:aa70e4364b270efb159db6ac01d9db165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bae7c286d5f21ab96a969983a18992a"><td class="memItemLeft" align="right" valign="top"><a id="a5bae7c286d5f21ab96a969983a18992a"></a>
virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_double_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a5bae7c286d5f21ab96a969983a18992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5c30330a03aa37fcd2f4e74d77f41"><td class="memItemLeft" align="right" valign="top"><a id="a3ae5c30330a03aa37fcd2f4e74d77f41"></a>
virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_string_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a3ae5c30330a03aa37fcd2f4e74d77f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05644a3e840a1f6dc903d015dc45eb8c"><td class="memItemLeft" align="right" valign="top"><a id="a05644a3e840a1f6dc903d015dc45eb8c"></a>
virtual std::vector&lt; shared_object &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_object_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:a05644a3e840a1f6dc903d015dc45eb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f03ed4ec91710e6e453c94e88a69bd"><td class="memItemLeft" align="right" valign="top"><a id="ae6f03ed4ec91710e6e453c94e88a69bd"></a>
virtual std::vector&lt; shared_config &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_config_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:ae6f03ed4ec91710e6e453c94e88a69bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3a34d6d98f7e287585e8e6a58fd927"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a9a3a34d6d98f7e287585e8e6a58fd927">get_duration</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>, time_unit unit) const</td></tr>
<tr class="memdesc:a9a3a34d6d98f7e287585e8e6a58fd927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value as an integer number of the specified units.  <a href="classhocon_1_1config.html#a9a3a34d6d98f7e287585e8e6a58fd927">More...</a><br /></td></tr>
<tr class="separator:a9a3a34d6d98f7e287585e8e6a58fd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12011680d05b805b8c7816353f3f4f62"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a12011680d05b805b8c7816353f3f4f62">with_only_path</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:a12011680d05b805b8c7816353f3f4f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the config with only the given path (and its children) retained; all sibling paths are removed.  <a href="classhocon_1_1config.html#a12011680d05b805b8c7816353f3f4f62">More...</a><br /></td></tr>
<tr class="separator:a12011680d05b805b8c7816353f3f4f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b87a2410bc78d37b7a804dcd9bf8c7"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a89b87a2410bc78d37b7a804dcd9bf8c7">without_path</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:a89b87a2410bc78d37b7a804dcd9bf8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the config with the given path removed.  <a href="classhocon_1_1config.html#a89b87a2410bc78d37b7a804dcd9bf8c7">More...</a><br /></td></tr>
<tr class="separator:a89b87a2410bc78d37b7a804dcd9bf8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4114325b36b55df0f96659eee203042"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ac4114325b36b55df0f96659eee203042">at_path</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="memdesc:ac4114325b36b55df0f96659eee203042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the config inside another.  <a href="classhocon_1_1config.html#ac4114325b36b55df0f96659eee203042">More...</a><br /></td></tr>
<tr class="separator:ac4114325b36b55df0f96659eee203042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314ffd274ea60165765980ff6f290ae6"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a314ffd274ea60165765980ff6f290ae6">at_key</a> (std::string const &amp;key) const</td></tr>
<tr class="memdesc:a314ffd274ea60165765980ff6f290ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the config inside a.  <a href="classhocon_1_1config.html#a314ffd274ea60165765980ff6f290ae6">More...</a><br /></td></tr>
<tr class="separator:a314ffd274ea60165765980ff6f290ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d816f94ec8199e7848e1ac41665338"><td class="memItemLeft" align="right" valign="top">virtual shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a20d816f94ec8199e7848e1ac41665338">with_value</a> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>, std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__value.html">config_value</a> &gt; <a class="el" href="classhocon_1_1value.html">value</a>) const</td></tr>
<tr class="memdesc:a20d816f94ec8199e7848e1ac41665338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a.  <a href="classhocon_1_1config.html#a20d816f94ec8199e7848e1ac41665338">More...</a><br /></td></tr>
<tr class="separator:a20d816f94ec8199e7848e1ac41665338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bac577324bf7ef8b59abca300fdbb02"><td class="memItemLeft" align="right" valign="top"><a id="a4bac577324bf7ef8b59abca300fdbb02"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classhocon_1_1config.html">config</a> const &amp;other) const</td></tr>
<tr class="separator:a4bac577324bf7ef8b59abca300fdbb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af376550dbba49cec0aa96c8804680706"><td class="memItemLeft" align="right" valign="top"><a id="af376550dbba49cec0aa96c8804680706"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>config</b> (shared_object object)</td></tr>
<tr class="separator:af376550dbba49cec0aa96c8804680706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3b460736e4d2e482d45cc2f690733"><td class="memItemLeft" align="right" valign="top"><a id="adcb3b460736e4d2e482d45cc2f690733"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adcb3b460736e4d2e482d45cc2f690733"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_homogeneous_unwrapped_list</b> (std::string const &amp;<a class="el" href="classhocon_1_1path.html">path</a>) const</td></tr>
<tr class="separator:adcb3b460736e4d2e482d45cc2f690733"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5cfd81276b3a2c7ac5b73efca9850451"><td class="memItemLeft" align="right" valign="top">static shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#a5cfd81276b3a2c7ac5b73efca9850451">parse_file_any_syntax</a> (std::string file_basename, <a class="el" href="classhocon_1_1config__parse__options.html">config_parse_options</a> options)</td></tr>
<tr class="memdesc:a5cfd81276b3a2c7ac5b73efca9850451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a file with a flexible extension.  <a href="classhocon_1_1config.html#a5cfd81276b3a2c7ac5b73efca9850451">More...</a><br /></td></tr>
<tr class="separator:a5cfd81276b3a2c7ac5b73efca9850451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aa1b78792b4f89f58c409746087060"><td class="memItemLeft" align="right" valign="top">static shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ae7aa1b78792b4f89f58c409746087060">parse_file_any_syntax</a> (std::string file_basename)</td></tr>
<tr class="memdesc:ae7aa1b78792b4f89f58c409746087060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="">parseFileAnySyntax(File,config_parse_options)</a> but always uses default parse options.  <a href="classhocon_1_1config.html#ae7aa1b78792b4f89f58c409746087060">More...</a><br /></td></tr>
<tr class="separator:ae7aa1b78792b4f89f58c409746087060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc12906f8c23e63817c8f6cbc142cf0"><td class="memItemLeft" align="right" valign="top">static shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#adcc12906f8c23e63817c8f6cbc142cf0">parse_string</a> (std::string s, <a class="el" href="classhocon_1_1config__parse__options.html">config_parse_options</a> options)</td></tr>
<tr class="memdesc:adcc12906f8c23e63817c8f6cbc142cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string (which should be valid HOCON or JSON by default, or the syntax specified in the options otherwise).  <a href="classhocon_1_1config.html#adcc12906f8c23e63817c8f6cbc142cf0">More...</a><br /></td></tr>
<tr class="separator:adcc12906f8c23e63817c8f6cbc142cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779f326fc405124f0a0cfa53dbc1971"><td class="memItemLeft" align="right" valign="top">static shared_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhocon_1_1config.html#ae779f326fc405124f0a0cfa53dbc1971">parse_string</a> (std::string s)</td></tr>
<tr class="memdesc:ae779f326fc405124f0a0cfa53dbc1971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string (which should be valid HOCON or JSON).  <a href="classhocon_1_1config.html#ae779f326fc405124f0a0cfa53dbc1971">More...</a><br /></td></tr>
<tr class="separator:ae779f326fc405124f0a0cfa53dbc1971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27da8d1c6b8e89d0012757d08b1698be"><td class="memItemLeft" align="right" valign="top"><a id="a27da8d1c6b8e89d0012757d08b1698be"></a>
static shared_object&#160;</td><td class="memItemRight" valign="bottom"><b>env_variables_as_config_object</b> ()</td></tr>
<tr class="separator:a27da8d1c6b8e89d0012757d08b1698be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaea861718d23732dda6746b162cb22e2"><td class="memItemLeft" align="right" valign="top"><a id="aaea861718d23732dda6746b162cb22e2"></a>
shared_value&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (std::string const &amp;path_expression, <a class="el" href="classhocon_1_1config__value.html#aa7a6a75b976a33f769af1e14695398f2">config_value::type</a> expected) const</td></tr>
<tr class="separator:aaea861718d23732dda6746b162cb22e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8306e5fe889db458ca5cc8e54818f"><td class="memItemLeft" align="right" valign="top"><a id="a75b8306e5fe889db458ca5cc8e54818f"></a>
shared_value&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (<a class="el" href="classhocon_1_1path.html">path</a> path_expression, <a class="el" href="classhocon_1_1config__value.html#aa7a6a75b976a33f769af1e14695398f2">config_value::type</a> expected, <a class="el" href="classhocon_1_1path.html">path</a> original_path) const</td></tr>
<tr class="separator:a75b8306e5fe889db458ca5cc8e54818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32668eba5ba4bc3f3dc11d43331b1ebc"><td class="memItemLeft" align="right" valign="top"><a id="a32668eba5ba4bc3f3dc11d43331b1ebc"></a>
shared_value&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (<a class="el" href="classhocon_1_1path.html">path</a> path_expression, <a class="el" href="classhocon_1_1config__value.html#aa7a6a75b976a33f769af1e14695398f2">config_value::type</a> expected) const</td></tr>
<tr class="separator:a32668eba5ba4bc3f3dc11d43331b1ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0157ca5440664790423876cb8a1eb2"><td class="memItemLeft" align="right" valign="top"><a id="a1e0157ca5440664790423876cb8a1eb2"></a>
shared_config&#160;</td><td class="memItemRight" valign="bottom"><b>at_key</b> (shared_origin <a class="el" href="classhocon_1_1config.html#a827dc49be531922ccb28d9cf8b99f4bf">origin</a>, std::string const &amp;key) const</td></tr>
<tr class="separator:a1e0157ca5440664790423876cb8a1eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abe2d0c46e999c7b2dfb8224a403cfc5c"><td class="memItemLeft" align="right" valign="top"><a id="abe2d0c46e999c7b2dfb8224a403cfc5c"></a>
static shared_includer&#160;</td><td class="memItemRight" valign="bottom"><b>default_includer</b> ()</td></tr>
<tr class="separator:abe2d0c46e999c7b2dfb8224a403cfc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad89d7d0fdba686885334a7f34923d8d8"><td class="memItemLeft" align="right" valign="top"><a id="ad89d7d0fdba686885334a7f34923d8d8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>config_object</b></td></tr>
<tr class="separator:ad89d7d0fdba686885334a7f34923d8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8edc9e5146976a0b4809bd174d2f708"><td class="memItemLeft" align="right" valign="top"><a id="ac8edc9e5146976a0b4809bd174d2f708"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>config_value</b></td></tr>
<tr class="separator:ac8edc9e5146976a0b4809bd174d2f708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad08504249b582bdb15e6e25400cc28"><td class="memItemLeft" align="right" valign="top"><a id="aaad08504249b582bdb15e6e25400cc28"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>config_parseable</b></td></tr>
<tr class="separator:aaad08504249b582bdb15e6e25400cc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123e1fb8449c4e7fe55f61d094334ea0"><td class="memItemLeft" align="right" valign="top"><a id="a123e1fb8449c4e7fe55f61d094334ea0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>parseable</b></td></tr>
<tr class="separator:a123e1fb8449c4e7fe55f61d094334ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An immutable map from config paths to config values. </p>
<p>Paths are dot-separated expressions such as <code>foo.bar.baz</code>. Values are as in JSON (booleans, strings, numbers, lists, or objects), represented by <a class="el" href="classhocon_1_1config__value.html">config_value</a> instances. Values accessed through the <code>config</code> interface are never null.</p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> is an immutable object and thus safe to use from multiple threads. There's never a need for "defensive copies."</p>
<p>Fundamental operations on a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> include getting configuration values, <em>resolving</em> substitutions with <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a>, and merging configs using <a class="el" href="">config#with_fallback(config_mergeable)</a>.</p>
<p>All operations return a new immutable</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> rather than modifying the original instance.</p>
<p><b>Examples</b></p>
<p>You can find an example app and library <a href="https://github.com/typesafehub/config/tree/master/examples">on GitHub</a>. Also be sure to read the <a href="package-summary.html#package_description">package overview</a> which describes the big picture as shown in those examples.</p>
<p><b>Paths, keys, and config vs. <a class="el" href="classhocon_1_1config__object.html">config_object</a></b></p>
<p><code>config</code> is a view onto a tree of <a class="el" href="classhocon_1_1config__object.html">config_object</a>; the corresponding object tree can be found through <a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">config#root()</a>. <code><a class="el" href="classhocon_1_1config__object.html">config_object</a></code> is a map from config <em>keys</em>, rather than paths, to config values. Think of <code><a class="el" href="classhocon_1_1config__object.html">config_object</a></code> as a JSON object and <code>config</code> as a configuration API.</p>
<p>The API tries to consistently use the terms "key" and "path." A key is a key in a JSON object; it's just a string that's the key in a map. A "path" is a parseable expression with a syntax and it refers to a series of keys. Path expressions are described in the <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">spec for Human-Optimized Config Object Notation</a>. In brief, a path is period-separated so "a.b.c" looks for key c in object b in object a in the root object. Sometimes double quotes are needed around special characters in path expressions.</p>
<p>The API for a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> is in terms of path expressions, while the API for a</p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> is in terms of keys. Conceptually,</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> is a one-level map from <em>paths</em> to values, while a </p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> is a tree of nested maps from <em>keys</em> to values.</p>
<p>Use <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a> to convert between path expressions and individual path elements (keys).</p>
<p>Another difference between</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> and</p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> is that conceptually,</p><div class="fragment"><div class="line">config_value </div>
</div><!-- fragment --><p> s with a <a class="el" href="classhocon_1_1config__value.html#af3442400148eefff116b8c57ee638d22">value_type()</a> of <a class="el" href="">NULL</a> exist in a </p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> , while a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> treats null values as if they were missing. (With the exception of two methods: <a class="el" href="classhocon_1_1config.html#abcf047253216dc24124def4f1a52cf7e">config#has_path_or_null</a> and <a class="el" href="classhocon_1_1config.html#a38a11684c9de3d5d80548013379f56aa">config#get_is_null</a> let you detect <code>null</code> values.)</p>
<p><b>Getting configuration values</b></p>
<p>The "getters" on a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> all work in the same way. They never return null, nor do they return a</p><div class="fragment"><div class="line">config_value </div>
</div><!-- fragment --><p> with <a class="el" href="classhocon_1_1config__value.html#af3442400148eefff116b8c57ee638d22">value_type()</a> of <a class="el" href="">NULL</a>. Instead, they throw <a class="el" href="structhocon_1_1config__exception.html">config_exception</a> if the value is completely absent or set to null. If the value is set to null, a subtype of </p><div class="fragment"><div class="line">config_exception.missing </div>
</div><!-- fragment --><p> called <a class="el" href="">config_exception.null</a> will be thrown. <a class="el" href="">config_excpetion.wrong_type</a> will be thrown anytime you ask for a type and the value has an incompatible type. Reasonable type conversions are performed for you though.</p>
<p><b>Iteration</b></p>
<p>If you want to iterate over the contents of a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> , you can get its </p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> with <a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">root()</a>, and then iterate over the </p><div class="fragment"><div class="line">config_object </div>
</div><!-- fragment --><p> (which implements <code>java.util.Map</code>). Or, you can use <a class="el" href="classhocon_1_1config.html#a83c5f8dca33d74f9976642f9187f22e3">entry_set()</a> which recurses the object tree for you and builds up a <code>set</code> of all path-value pairs where the value is not null.</p>
<p><b>Resolving substitutions</b></p>
<p><em>Substitutions</em> are the <code>${foo.bar}</code> syntax in config files, described in the <a href="https://github.com/typesafehub/config/blob/master/HOCON.md#substitutions">specification</a>. Resolving substitutions replaces these references with real values.</p>
<p>Before using a</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> it's necessary to call <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> to handle substitutions (though <a class="el" href="">config_factory#load()</a> and similar methods will do the resolve for you already).</p>
<p><b>Merging</b></p>
<p>The full <code>config</code> for your application can be constructed using the associative operation <a class="el" href="">config#with_fallback(config_mergeable)</a>. If you use <a class="el" href="">config_factory#load()</a> (recommended), it merges system properties over the top of <code>application.conf</code> over the top of <code>reference.conf</code>, using <code>with_fallback</code>. You can add in additional sources of configuration in the same way (usually, custom layers should go either just above or just below <code>application.conf</code>, keeping <code>reference.conf</code> at the bottom and system properties at the top).</p>
<p><b>Serialization</b></p>
<p>Convert a <code>config</code> to a JSON or HOCON string by calling <a class="el" href="classhocon_1_1config__value.html#af7dd87e4e401a355639dd8277a8b5580">config_object#render()</a> on the root object, <code>my_config.root().render()</code>. There's also a variant <a class="el" href="">config_object#render(config_render_options)</a> which allows you to control the format of the rendered string. (See <a class="el" href="classhocon_1_1config__render__options.html">config_render_options</a>.) Note that <code>config</code> does not remember the formatting of the original file, so if you load, modify, and re-save a config file, it will be substantially reformatted.</p>
<p>As an alternative to <a class="el" href="classhocon_1_1config__value.html#af7dd87e4e401a355639dd8277a8b5580">config_object#render()</a>, the <code>to_string()</code> method produces a debug-output-oriented representation (which is not valid JSON).</p>
<p><b>This is an interface but don't implement it yourself</b></p>
<p><em>Do not implement</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> </em>; it should only be implemented by the config library. Arbitrary implementations will not work because the library internals assume a specific concrete implementation. Also, this interface is likely to grow new methods over time, so third-party implementations will break. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00172">172</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a314ffd274ea60165765980ff6f290ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314ffd274ea60165765980ff6f290ae6">&#9670;&nbsp;</a></span>at_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::at_key </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places the config inside a. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> at the given key. See also <a class="el" href="classhocon_1_1config.html#ac4114325b36b55df0f96659eee203042" title="Places the config inside another.">at_path()</a>. Note that a key is NOT a path expression (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to store this config at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a<div class="fragment"><div class="line">config </div>
</div><!-- fragment --> instance containing this config at the given key. </dd></dl>

</div>
</div>
<a id="ac4114325b36b55df0f96659eee203042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4114325b36b55df0f96659eee203042">&#9670;&nbsp;</a></span>at_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::at_path </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places the config inside another. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> at the given path. </p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path expression to store this config at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a<div class="fragment"><div class="line">config </div>
</div><!-- fragment --> instance containing this config at the given path. </dd></dl>

</div>
</div>
<a id="ae63746e9542665eea20a51929b7fc150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63746e9542665eea20a51929b7fc150">&#9670;&nbsp;</a></span>check_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hocon::config::check_valid </td>
          <td>(</td>
          <td class="paramtype">shared_config&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>restrict_to_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates this config against a reference config, throwing an exception if it is invalid. </p>
<p>The purpose of this method is to "fail early" with a comprehensive list of problems; in general, anything this method can find would be detected later when trying to use the config, but it's often more user-friendly to fail right away when loading the config.</p>
<p>Using this method is always optional, since you can "fail late" instead.</p>
<p>You must restrict validation to paths you "own" (those whose meaning are defined by your code module). If you validate globally, you may trigger errors about paths that happen to be in the config but have nothing to do with your module. It's best to allow the modules owning those paths to validate them. Also, if every module validates only its own stuff, there isn't as much redundant work being done.</p>
<p>If no paths are specified in <code><a class="el" href="classhocon_1_1config.html#ae63746e9542665eea20a51929b7fc150" title="Validates this config against a reference config, throwing an exception if it is invalid.">check_valid()</a></code>'s parameter list, validation is for the entire config.</p>
<p>If you specify paths that are not in the reference config, those paths are ignored. (There's nothing to validate.)</p>
<p>Here's what validation involves:</p>
<ul>
<li>
All paths found in the reference config must be present in this config or an exception will be thrown. </li>
<li>
Some changes in type from the reference config to this config will cause an exception to be thrown. Not all potential type problems are detected, in particular it's assumed that strings are compatible with everything except objects and lists. This is because string types are often "really" some other type (system properties always start out as strings, or a string like "5ms" could be used with <a class="el" href="">get_milliseconds</a>). Also, it's allowed to set any type to null or override null with any type. </li>
<li>
Any unresolved substitutions in this config will cause a validation failure; both the reference config and this config should be resolved before validation. If the reference config is unresolved, it's a bug in the caller of this method. </li>
</ul>
<p>If you want to allow a certain setting to have a flexible type (or otherwise want validation to be looser for some settings), you could either remove the problematic setting from the reference config provided to this method, or you could intercept the validation exception and screen out certain problems. Of course, this will only work if all other callers of this method are careful to restrict validation to their own paths, as they should be.</p>
<p>If validation fails, the thrown exception contains a list of all problems found. The exception will have all the problem concatenated into one huge string.</p>
<p>Again, <code><a class="el" href="classhocon_1_1config.html#ae63746e9542665eea20a51929b7fc150" title="Validates this config against a reference config, throwing an exception if it is invalid.">check_valid()</a></code> can't guess every domain-specific way a setting can be invalid, so some problems may arise later when attempting to use the config. <code><a class="el" href="classhocon_1_1config.html#ae63746e9542665eea20a51929b7fc150" title="Validates this config against a reference config, throwing an exception if it is invalid.">check_valid()</a></code> is limited to reporting generic, but common, problems such as missing settings and blatant type incompatibilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>a reference configuration </td></tr>
    <tr><td class="paramname">restrictToPaths</td><td>only validate values underneath these paths that your code module owns and understands </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83c5f8dca33d74f9976642f9187f22e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c5f8dca33d74f9976642f9187f22e3">&#9670;&nbsp;</a></span>entry_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::set&lt;std::pair&lt;std::string, std::shared_ptr&lt;const <a class="el" href="classhocon_1_1config__value.html">config_value</a>&gt; &gt; &gt; hocon::config::entry_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of path-value pairs, excluding any null values, found by recursing <a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41">the root object</a>. </p>
<p>Note that this is very different from <code><a class="el" href="classhocon_1_1config.html#ac23eb9445b4eb9f48fc9bcd96e965b41" title="Gets the.">root()</a>.<a class="el" href="classhocon_1_1config.html#a83c5f8dca33d74f9976642f9187f22e3" title="Returns the set of path-value pairs, excluding any null values, found by recursing the root object.">entry_set()</a></code> which returns the set of immediate-child keys in the root object and includes null values. </p>
<p>Entries contain <em>path expressions</em> meaning there may be quoting and escaping involved. Parse path expressions with <a class="el" href="">config_util#split_path</a>. </p>
<p>Because a <code>config</code> is conceptually a single-level map from paths to values, there will not be any <a class="el" href="classhocon_1_1config__object.html">config_object</a> values in the entries (that is, all entries represent leaf nodes). Use <a class="el" href="classhocon_1_1config__object.html">config_object</a> rather than <code>config</code> if you want a tree. (OK, this is a slight lie: <code>config</code> entries may contain <a class="el" href="classhocon_1_1config__list.html">config_list</a> and the lists may contain objects. But no objects are directly included as entry values.)</p>
<dl class="section return"><dt>Returns</dt><dd>set of paths with non-null values, built up by recursing the entire tree of <a class="el" href="classhocon_1_1config__object.html">config_object</a> and creating an entry for each leaf value. </dd></dl>

</div>
</div>
<a id="a9a3a34d6d98f7e287585e8e6a58fd927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3a34d6d98f7e287585e8e6a58fd927">&#9670;&nbsp;</a></span>get_duration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t hocon::config::get_duration </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_unit&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value as an integer number of the specified units. </p>
<p>If the result would have a fractional part, the number is truncated. Correctly handles durations within the range +/-2^63 seconds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the time value </td></tr>
    <tr><td class="paramname">unit</td><td>the units of the number returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 64-bit integer representing the value converted to the requested units </dd></dl>

</div>
</div>
<a id="a38a11684c9de3d5d80548013379f56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a11684c9de3d5d80548013379f56aa">&#9670;&nbsp;</a></span>get_is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hocon::config::get_is_null </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is set to null at the given path, but throws an exception if the value is entirely unset. </p>
<p>This method will not throw if {<a class="el" href="">} returned true for the same path, so to avoid any possible exception check <code>has_path_or_null()</code> first. However, an exception for unset paths will usually be the right thing (because a <code>reference.conf</code> should exist that has the path set, the path should never be unset unless something is broken). </a> Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value exists and is null, false if it exists and is not null </dd></dl>

</div>
</div>
<a id="adb726d491df1958769dfb4b53c117c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb726d491df1958769dfb4b53c117c9d">&#9670;&nbsp;</a></span>has_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hocon::config::has_path </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is present and non-null at the given path. </p>
<p>This differs in two ways from</p><div class="fragment"><div class="line">Map.containsKey() </div>
</div><!-- fragment --><p> as implemented by <a class="el" href="classhocon_1_1config__object.html">config_object</a>: it looks for a path expression, not a key; and it returns false for null values, while</p><div class="fragment"><div class="line">contains_key() </div>
</div><!-- fragment --><p> returns true indicating that the object contains a null value for the key.</p>
<p>If a path exists according to <a class="el" href="">has_path(string)</a>, then <a class="el" href="">get_value(string)</a> will never throw an exception. However, the typed getters will still throw if the value is not convertible to the requested type.</p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a non-null value is present at the path </dd></dl>

</div>
</div>
<a id="abcf047253216dc24124def4f1a52cf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf047253216dc24124def4f1a52cf7e">&#9670;&nbsp;</a></span>has_path_or_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hocon::config::has_path_or_null </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is present at the given path, even if the value is null. </p>
<p>Most of the getters on <code>config</code> will throw if you try to get a null value, so if you plan to call <a class="el" href="">get_value(string)</a>, <a class="el" href="">get_int(string)</a>, or another getter you may want to use plain <a class="el" href="">has_path(string)</a> rather than this method.</p>
<p>To handle all three cases (unset, null, and a non-null value) the code might look like: </p><pre><code>
if (config.has_path_or_null(path)) {
    if (config.get_is_null(path)) {
       // handle null setting
    } else {
       // get and use non-null setting
    }
} else {
    // handle entirely unset path
}
</code></pre><p>However, the usual thing is to allow entirely unset paths to be a bug that throws an exception (because you set a default in your <code>reference.conf</code>), so in that case it's OK to call <a class="el" href="">get_is_null(string)</a> without checking <code>has_path_or_null</code> first.</p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value is present at the path, even if the value is null </dd></dl>

</div>
</div>
<a id="a84dc18b07cc713ca64bbb7884a478566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dc18b07cc713ca64bbb7884a478566">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hocon::config::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> 's root object contains no key-value pairs.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the configuration is empty </dd></dl>

</div>
</div>
<a id="a30d1e4c68c2094d22f5a3234c48e1ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d1e4c68c2094d22f5a3234c48e1ce9">&#9670;&nbsp;</a></span>is_resolved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hocon::config::is_resolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the config is completely resolved. </p>
<p>After a successful call to <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> it will be completely resolved, but after calling <a class="el" href="">config#resolve(config_resolve_options)</a> with <code>allow_unresolved</code> set in the options, it may or may not be completely resolved. A newly-loaded config may or may not be completely resolved depending on whether there were substitutions present in the file.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there are no unresolved substitutions remaining in this configuration. </dd></dl>

</div>
</div>
<a id="a827dc49be531922ccb28d9cf8b99f4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827dc49be531922ccb28d9cf8b99f4bf">&#9670;&nbsp;</a></span>origin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_origin hocon::config::origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the origin of the. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> , which may be a file, or a file with a line number, or just a descriptive phrase.</p>
<dl class="section return"><dt>Returns</dt><dd>the origin of the<div class="fragment"><div class="line">config </div>
</div><!-- fragment --> for use in error messages </dd></dl>

</div>
</div>
<a id="ae7aa1b78792b4f89f58c409746087060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aa1b78792b4f89f58c409746087060">&#9670;&nbsp;</a></span>parse_file_any_syntax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static shared_config hocon::config::parse_file_any_syntax </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_basename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="">parseFileAnySyntax(File,config_parse_options)</a> but always uses default parse options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileBasename</td><td>a filename with or without extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed configuration </dd></dl>

</div>
</div>
<a id="a5cfd81276b3a2c7ac5b73efca9850451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd81276b3a2c7ac5b73efca9850451">&#9670;&nbsp;</a></span>parse_file_any_syntax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static shared_config hocon::config::parse_file_any_syntax </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhocon_1_1config__parse__options.html">config_parse_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a file with a flexible extension. </p>
<p>If the <code>fileBasename</code> already ends in a known extension, this method parses it according to that extension (the file's syntax must match its extension). If the <code>fileBasename</code> does not end in an extension, it parses files with all known extensions and merges whatever is found.</p>
<p>In the current implementation, the extension ".conf" forces <a class="el" href="#aec57788de2eb4bde7a1b2a60c69b82e3a8d428c502adec040b6a51e880034b9f4">config_syntax#CONF</a>, ".json" forces <a class="el" href="#aec57788de2eb4bde7a1b2a60c69b82e3a0ecd11c1d7a287401d148a23bbd7a2f8">config_syntax#JSON</a>. When merging files, ".conf" falls back to ".json".</p>
<p>Future versions of the implementation may add additional syntaxes or additional extensions. However, the ordering (fallback priority) of the three current extensions will remain the same.</p>
<p>If <code>options</code> forces a specific syntax, this method only parses files with an extension matching that syntax.</p>
<p>If <a class="el" href="">options.getAllowMissing()</a> is true, then no files have to exist; if false, then at least one file has to exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileBasename</td><td>a filename with or without extension </td></tr>
    <tr><td class="paramname">options</td><td>parse options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed configuration </dd></dl>

</div>
</div>
<a id="ae779f326fc405124f0a0cfa53dbc1971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779f326fc405124f0a0cfa53dbc1971">&#9670;&nbsp;</a></span>parse_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static shared_config hocon::config::parse_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a string (which should be valid HOCON or JSON). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed configuration </dd></dl>

</div>
</div>
<a id="adcc12906f8c23e63817c8f6cbc142cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc12906f8c23e63817c8f6cbc142cf0">&#9670;&nbsp;</a></span>parse_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static shared_config hocon::config::parse_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhocon_1_1config__parse__options.html">config_parse_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a string (which should be valid HOCON or JSON by default, or the syntax specified in the options otherwise). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to parse </td></tr>
    <tr><td class="paramname">options</td><td>parse options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed configuration </dd></dl>

</div>
</div>
<a id="af03830d94e132e03db0c62a74dc0bfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03830d94e132e03db0c62a74dc0bfb4">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a replacement config with all substitutions (the <code>${foo.bar}</code> syntax, see <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">the spec</a>) resolved. </p>
<p>Substitutions are looked up using this <code>config</code> as the root object, that is, a substitution <code>${foo.bar}</code> will be replaced with the result of <code>get_value("foo.bar")</code>.</p>
<p>This method uses <a class="el" href="">config_resolve_options()</a>, there is another variant <a class="el" href="">config#resolve(config_resolve_options)</a> which lets you specify non-default options.</p>
<p>A given <a class="el" href="classhocon_1_1config.html">config</a> must be resolved before using it to retrieve config values, but ideally should be resolved one time for your entire stack of fallbacks (see <a class="el" href="classhocon_1_1config.html#a67c6037de7029e7a99c053257cf405c2">config#with_fallback</a>). Otherwise, some substitutions that could have resolved with all fallbacks available may not resolve, which will be potentially confusing for your application's users.</p>
<p><code><a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4" title="Returns a replacement config with all substitutions (the ${foo.bar} syntax, see the spec) resolved.">resolve()</a></code> should be invoked on root config objects, rather than on a subtree (a subtree is the result of something like <code>config.get_config("foo")</code>). The problem with <code><a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4" title="Returns a replacement config with all substitutions (the ${foo.bar} syntax, see the spec) resolved.">resolve()</a></code> on a subtree is that substitutions are relative to the root of the config and the subtree will have no way to get values from the root. For example, if you did <code>config.get_config("foo").<a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4" title="Returns a replacement config with all substitutions (the ${foo.bar} syntax, see the spec) resolved.">resolve()</a></code> on the below config file, it would not work:</p>
<pre>
  common-value = 10
  foo {
     whatever = ${common-value}
  }
</pre><p>Many methods on <a class="el" href="">config_factory</a> such as <a class="el" href="">config_factory#load()</a> automatically resolve the loaded <code>config</code> on the loaded stack of config files.</p>
<p>Resolving an already-resolved config is a harmless no-op, but again, it is best to resolve an entire stack of fallbacks (such as all your config files combined) rather than resolving each one individually.</p>
<dl class="section return"><dt>Returns</dt><dd>an immutable object with substitutions resolved </dd></dl>

</div>
</div>
<a id="acb4d59038675d2c7981b70d6d956cc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4d59038675d2c7981b70d6d956cc03">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhocon_1_1config__resolve__options.html">config_resolve_options</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> but allows you to specify non-default options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>resolve options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resolved <code>config</code> (may be only partially resolved if options are set to allow unresolved) </dd></dl>

</div>
</div>
<a id="ae857c18ea9ed5d9274092e6fcbf5bfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae857c18ea9ed5d9274092e6fcbf5bfbb">&#9670;&nbsp;</a></span>resolve_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::resolve_with </td>
          <td>(</td>
          <td class="paramtype">shared_config&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classhocon_1_1config.html#af03830d94e132e03db0c62a74dc0bfb4">config#resolve()</a> except that substitution values are looked up in the given source, rather than in this instance. </p>
<p>This is a special-purpose method which doesn't make sense to use in most cases; it's only needed if you're constructing some sort of app-specific custom approach to configuration. The more usual approach if you have a source of substitution values would be to merge that source into your config stack using <a class="el" href="">config#withFallback</a> and then resolve. </p>
<p>Note that this method does NOT look in this instance for substitution values. If you want to do that, you could either merge this instance into your value source using <a class="el" href="classhocon_1_1config.html#a67c6037de7029e7a99c053257cf405c2">config#with_fallback</a>, or you could resolve multiple times with multiple sources (using <a class="el" href="">config_resolve_options#setAllowUnresolved(boolean)</a> so the partial resolves don't fail).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>configuration to pull values from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an immutable object with substitutions resolved </dd></dl>

</div>
</div>
<a id="a938ee4aacd961d7c7f6f2aa04e651c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938ee4aacd961d7c7f6f2aa04e651c85">&#9670;&nbsp;</a></span>resolve_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::resolve_with </td>
          <td>(</td>
          <td class="paramtype">shared_config&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhocon_1_1config__resolve__options.html">config_resolve_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="">config#resolve_with(config)</a> but allows you to specify non-default options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source configuration to pull values from </td></tr>
    <tr><td class="paramname">options</td><td>resolve options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resolved <code>config</code> (may be only partially resolved if options are set to allow unresolved) </dd></dl>

</div>
</div>
<a id="ac23eb9445b4eb9f48fc9bcd96e965b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23eb9445b4eb9f48fc9bcd96e965b41">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_object hocon::config::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> as a tree of <a class="el" href="classhocon_1_1config__object.html">config_object</a>. This is a constant-time operation (it is not proportional to the number of values in the</p><div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> ).</p>
<dl class="section return"><dt>Returns</dt><dd>the root object in the configuration </dd></dl>

</div>
</div>
<a id="a92b8f810965c489ec3946c632880ac85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b8f810965c489ec3946c632880ac85">&#9670;&nbsp;</a></span>to_fallback_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_value hocon::config::to_fallback_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a config to its root object and a <a class="el" href="classhocon_1_1config__value.html" title="An immutable value, following the JSON type schema.">config_value</a> to itself. </p>
<p>Originally in the MergeableValue interface, squashing to ease C++ public API separation </p>

<p>Implements <a class="el" href="classhocon_1_1config__mergeable.html#a428be48dba253d533643080a8934ea09">hocon::config_mergeable</a>.</p>

</div>
</div>
<a id="a67c6037de7029e7a99c053257cf405c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6037de7029e7a99c053257cf405c2">&#9670;&nbsp;</a></span>with_fallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classhocon_1_1config__mergeable.html">config_mergeable</a>&gt; hocon::config::with_fallback </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__mergeable.html">config_mergeable</a> &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new value computed by merging this value with another, with keys in this value "winning" over the other one. </p>
<p>This associative operation may be used to combine configurations from multiple sources (such as multiple configuration files).</p>
<p>The semantics of merging are described in the <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">spec for HOCON</a>. Merging typically occurs when either the same object is created twice in the same file, or two config files are both loaded. For example:</p>
<pre>
 foo = { a: 42 }
 foo = { b: 43 }
</pre><p>Here, the two objects are merged as if you had written:</p>
<pre>
 foo = { a: 42, b: 43 }
</pre><p>Only <a class="el" href="classhocon_1_1config__object.html">config_object</a> and <a class="el" href="classhocon_1_1config.html">config</a> instances do anything in this method (they need to merge the fallback keys into themselves). All other values just return the original value, since they automatically override any fallback. This means that objects do not merge "across" non-objects; if you write <code>object.withFallback(nonObject).withFallback(otherObject)</code>, then <code>otherObject</code> will simply be ignored. This is an intentional part of how merging works, because non-objects such as strings and integers replace (rather than merging with) any prior value:</p>
<pre>
foo = { a: 42 }
foo = 10
</pre><p>Here, the number 10 "wins" and the value of <code>foo</code> would be simply 10. Again, for details see the spec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>an object whose keys should be used as fallbacks, if the keys are not present in this one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object (or the original one, if the fallback doesn't get used) </dd></dl>

<p>Implements <a class="el" href="classhocon_1_1config__mergeable.html#a7b52c8c1cca8e617b34ea9eb439c8f59">hocon::config_mergeable</a>.</p>

</div>
</div>
<a id="a12011680d05b805b8c7816353f3f4f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12011680d05b805b8c7816353f3f4f62">&#9670;&nbsp;</a></span>with_only_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::with_only_path </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the config with only the given path (and its children) retained; all sibling paths are removed. </p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path to keep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the config minus all paths except the one specified </dd></dl>

</div>
</div>
<a id="a20d816f94ec8199e7848e1ac41665338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d816f94ec8199e7848e1ac41665338">&#9670;&nbsp;</a></span>with_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::with_value </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classhocon_1_1config__value.html">config_value</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a. </p>
<div class="fragment"><div class="line">config </div>
</div><!-- fragment --><p> based on this one, but with the given path set to the given value. Does not modify this instance (since it's immutable). If the path already has a value, that value is replaced. To remove a value, use withoutPath(). </p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path expression for the value's new location </td></tr>
    <tr><td class="paramname">value</td><td>value at the new path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new instance with the new map entry </dd></dl>

</div>
</div>
<a id="a89b87a2410bc78d37b7a804dcd9bf8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b87a2410bc78d37b7a804dcd9bf8c7">&#9670;&nbsp;</a></span>without_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_config hocon::config::without_path </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the config with the given path removed. </p>
<p>Note that path expressions have a syntax and sometimes require quoting (see <a class="el" href="">config_util#join_path</a> and <a class="el" href="">config_util#split_path</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path expression to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the config minus the specified path </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hocon/<a class="el" href="config_8hpp_source.html">config.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 12 2020 09:47:37 for cpp-hocon by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
